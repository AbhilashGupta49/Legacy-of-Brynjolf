package com.hollowambitionproject.legacyofbrynjolf.service;

import static com.hollowambitionproject.legacyofbrynjolf.constant.ApplicationConstants.MAX_UNDECIDED_MOVES;

import java.util.Queue;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.hollowambitionproject.legacyofbrynjolf.constant.Direction;
import com.hollowambitionproject.legacyofbrynjolf.constant.MoveResult;
import com.hollowambitionproject.legacyofbrynjolf.domain.GameResult;
import com.hollowambitionproject.legacyofbrynjolf.domain.Room;
import com.hollowambitionproject.legacyofbrynjolf.exception.InvalidMoveException;
import com.hollowambitionproject.legacyofbrynjolf.util.DirectionUtil;

/**
 * The Class MovesExecutionServiceImpl. Used for executing moves provided by
 * user or generated by program.
 */
@Component
public class MovesExecutionServiceImpl implements MovesExecutionService {

	/** The Constant LOG. */
	private static final Logger LOG = LogManager.getLogger(MovesExecutionServiceImpl.class);

	/** The modify room service. */
	private ModifyRoomService modifyRoomService;

	/** The moves generator service. */
	private MovesGeneratorService movesGeneratorService;

	/**
	 * Instantiates a new moves execution service impl.
	 *
	 * @param modifyRoomService     the modify room service
	 * @param movesGeneratorService the moves generator service
	 */
	@Autowired
	public MovesExecutionServiceImpl(ModifyRoomService modifyRoomService, MovesGeneratorService movesGeneratorService) {
		this.modifyRoomService = modifyRoomService;
		this.movesGeneratorService = movesGeneratorService;
	}

	/**
	 * Execute a set of moves. Moves can be user defined or program generated.
	 *
	 * @param room  the room
	 * @param moves the moves
	 * @return the game result
	 */
	@Override
	public GameResult executeMoves(Room room, String moves) {
		// Used for keeping track if matrix is not modified after execution after
		// particular number of moves.
		int undecidedMoves = MAX_UNDECIDED_MOVES;
		GameResult gameResult = new GameResult(room, moves);
		for (int i = 0; i < moves.length(); i++) {
			// Keep track of which direction is executing.
			gameResult.setCurrentMovesCount(gameResult.getCurrentMovesCount() + 1);
			MoveResult moveResult = null;
			Direction direction = null;
			try {
				// Gets enum for a direction character.
				direction = DirectionUtil.getDirection(moves.charAt(i));
			} catch (InvalidMoveException e) {
				LOG.error("Invalid Move. Exiting Application!");
				Runtime runtime = Runtime.getRuntime();
				runtime.exit(1);
			}

			// Modifies the matrix by moving actors.
			moveResult = modifyRoomService.move(room, direction);
			gameResult.setMoveResult(moveResult);
			LOG.debug("Move Complete: {}", direction.name());

			// Checks what the result of a move is and performs actions accordingly.
			if (moveResult == MoveResult.LOSE || moveResult == MoveResult.WIN) {
				return gameResult;
			} else if (moveResult == MoveResult.MOVED) {
				undecidedMoves = MAX_UNDECIDED_MOVES;
			} else if (moveResult == MoveResult.UNMOVED) {
				undecidedMoves--;
				if (undecidedMoves == 0) {
					// Returns that the actors have not moved for the last (n) number of moves.
					return gameResult;
				}
			}
		}
		gameResult.setMoveResult(MoveResult.UNDECIDED);
		return gameResult;
	}

	/**
	 * Execute additional moves.
	 *
	 * @param gameResult the game result
	 */
	@Override
	public void executeAdditionalMoves(GameResult gameResult) {
		// Gets the possible permutations for next length by adding a direction. First
		// all permutations of a particular length are tried and then next length for
		// the passing permutations.
		Queue<String> additionalMoves = movesGeneratorService.generateNextMoves("");
		while (!additionalMoves.isEmpty()) {
			String moves = additionalMoves.remove();
			LOG.debug("Trying: {}{}", gameResult.getMoves(), moves);
			gameResult.setAdditionalMoves(moves);

			// Tries one permutation on a copy of matrix and gets the result.
			GameResult permutationResult = executeMoves(gameResult.getRoom().clone(), gameResult.getAdditionalMoves());
			Room room = permutationResult.getRoom();
			gameResult.setMoveResult(permutationResult.getMoveResult());
			MoveResult moveResult = gameResult.getMoveResult();

			if (moveResult == MoveResult.WIN) {
				// If a permutation is successful, return the result and the final room.
				gameResult.setMoveResult(MoveResult.WIN_ADDITIONAL_MOVES);
				gameResult.setRoom(room);
				return;
			} else if (moveResult == MoveResult.UNDECIDED) {
				// If a permutation did not conclude and it is possible to take another step,
				// then add the next length of permutations to the queue.
				Queue<String> temp = movesGeneratorService.generateNextMoves(moves);
				if (temp != null) {
					additionalMoves.addAll(temp);
				}
			}
		}
		gameResult.setAdditionalMoves("");
		gameResult.setMoveResult(MoveResult.STUCK);
	}

}
